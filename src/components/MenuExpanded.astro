---
import { t } from '@i18n/utils';

interface Props {
  activeSection: string;
  locale: string;
  class?: string;
}

const { activeSection, locale, class: className } = Astro.props;
const i18n = t(locale);

/**
 * Menu items — two types:
 * - "simple" items (Home, Contact): hug-content width, single label
 * - "work" items: full-width with category on left + subcategory on right
 */
const menuItems = [
  { id: 'home', label: i18n.menu.home, type: 'simple' as const },
  { id: 'work-social-media', category: i18n.menu.work, label: i18n.work.pages.socialMedia.title, type: 'work' as const },
  { id: 'work-product-photography', category: i18n.menu.work, label: i18n.work.pages.productPhotography.title, type: 'work' as const },
  { id: 'work-key-visuals', category: i18n.menu.work, label: i18n.work.pages.keyVisuals.title, type: 'work' as const },
  { id: 'contact', label: i18n.menu.contact, type: 'simple' as const },
];
---

<nav class:list={['menu-expanded', className]} aria-label="Main navigation" data-menu="expanded">
  <div class="menu-overlay" data-menu-overlay></div>
  <div class="menu-content" data-menu-content>
    <div class="menu-items">
      {menuItems.map((item) => (
        <button
          class:list={[
            'menu-item',
            { active: item.id === activeSection },
            { 'menu-item--work': item.type === 'work' },
          ]}
          data-menu-target={item.id}
          type="button"
        >
          {item.type === 'work' ? (
            <>
              <span>{item.category}</span>
              <span>{item.label}</span>
            </>
          ) : (
            <span>{item.label}</span>
          )}
        </button>
      ))}
    </div>
    <button
      class="close-btn"
      type="button"
      aria-label={i18n.menu.close}
      data-menu-close
    >
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M5 5L19 19M19 5L5 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      </svg>
    </button>
  </div>
</nav>

<script>
  import { gsap } from 'gsap';
  import { ScrollToPlugin } from 'gsap/ScrollToPlugin';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';
  import {
    MENU_ITEM_STAGGER,
    MENU_ITEM_DURATION,
    MENU_ITEM_OFFSET,
    MENU_ITEM_EASE,
    MENU_FADE_IN_DURATION,
    MENU_FADE_OUT_DURATION,
    MENU_SCROLL_DURATION,
    MENU_SCROLL_EASE,
  } from '@lib/animations/config';

  gsap.registerPlugin(ScrollToPlugin, ScrollTrigger);

  const nav = document.querySelector<HTMLElement>('[data-menu="expanded"]');
  const overlayBg = nav?.querySelector<HTMLElement>('[data-menu-overlay]');
  const content = nav?.querySelector<HTMLElement>('[data-menu-content]');
  const items = nav?.querySelectorAll<HTMLElement>('.menu-item');
  const closeBtn = nav?.querySelector<HTMLElement>('[data-menu-close]');

  if (nav && overlayBg && content && items && closeBtn) {
    let isOpen = false;
    const menuWrapper = document.querySelector<HTMLElement>('.menu-wrapper');

    // ---------- Position content aligned with collapsed menu ----------
    function positionContent(): void {
      const collapsed = document.querySelector<HTMLElement>('.menu-collapsed');
      if (!collapsed) return;

      const rect = collapsed.getBoundingClientRect();
      const vh = window.innerHeight;

      // Bottom of expanded content aligns with bottom of collapsed pill
      // Left edge aligns with left edge of collapsed pill
      content!.style.left = `${rect.left}px`;
      content!.style.bottom = `${vh - rect.bottom}px`;
    }

    // ---------- Open ----------
    function open(currentSection?: string): void {
      if (isOpen) return;
      isOpen = true;

      // Update active state
      if (currentSection) {
        items!.forEach((btn) => {
          const isActive = btn.dataset.menuTarget === currentSection;
          btn.classList.toggle('active', isActive);
        });
      }

      // Hide collapsed menu (opacity instead of visibility — GSAP sets
      // visibility:visible on child spans, which overrides parent visibility:hidden)
      if (menuWrapper) menuWrapper.style.opacity = '0';

      // Block page scroll
      document.documentElement.style.overflow = 'hidden';

      // Position content relative to collapsed menu
      positionContent();

      // Show nav container
      nav!.style.display = 'block';

      // Fade in overlay background
      gsap.fromTo(overlayBg!, { opacity: 0 }, {
        opacity: 1,
        duration: MENU_FADE_IN_DURATION,
        ease: 'power2.out',
      });

      // Close button visible immediately (no animation)
      gsap.set(closeBtn!, { opacity: 1, y: 0 });

      // Staggered bottom-up entrance: last item animates first
      const itemsArray = Array.from(items!);
      const reversed = [...itemsArray].reverse();
      gsap.fromTo(reversed,
        { opacity: 0, y: MENU_ITEM_OFFSET },
        {
          opacity: 1,
          y: 0,
          duration: MENU_ITEM_DURATION,
          stagger: MENU_ITEM_STAGGER,
          ease: MENU_ITEM_EASE,
        },
      );
    }

    // ---------- Close ----------
    function close(callback?: () => void): void {
      if (!isOpen) return;
      isOpen = false;

      // Fade out everything
      gsap.to(overlayBg!, {
        opacity: 0,
        duration: MENU_FADE_OUT_DURATION,
        ease: 'power2.in',
      });

      gsap.to(closeBtn!, { opacity: 0, duration: MENU_FADE_OUT_DURATION, ease: 'power2.in' });
      gsap.to(Array.from(items!), {
        opacity: 0,
        y: MENU_ITEM_OFFSET / 2,
        duration: MENU_FADE_OUT_DURATION,
        ease: 'power2.in',
        onComplete: () => {
          nav!.style.display = 'none';
          // Restore collapsed menu and scroll
          if (menuWrapper) menuWrapper.style.opacity = '1';
          document.documentElement.style.overflow = '';
          callback?.();
        },
      });
    }

    // ---------- Scroll-to-section logic ----------
    function getScrollTarget(targetId: string): number {
      // Get the ScrollTrigger instance that pins .hero
      const triggers = ScrollTrigger.getAll();
      const heroTrigger = triggers.find(
        (st) => (st.trigger as HTMLElement)?.classList.contains('hero'),
      );

      if (!heroTrigger) return 0;

      const triggerStart = heroTrigger.start;
      const triggerEnd = heroTrigger.end;
      const totalDist = triggerEnd - triggerStart;

      // We need to know the intro/page-scroll boundary.
      // The hero has page children — count them to compute intro end.
      const hero = document.querySelector<HTMLElement>('.hero');
      const isDesktop = window.innerWidth > 768;
      const scrollSection = hero?.querySelector<HTMLElement>(
        isDesktop ? '[data-scroll="page-scroll"]' : '[data-scroll="page-scroll-mobile"]',
      );
      const track = scrollSection?.querySelector<HTMLElement>('.page-scroll-track');
      const pageCount = track?.children.length ?? 0;

      // Measure CSS 100vh for mobile calculations
      const measureDiv = document.createElement('div');
      measureDiv.style.cssText = 'position:fixed;top:0;height:100vh;pointer-events:none;visibility:hidden;';
      document.body.appendChild(measureDiv);
      const cssVh = measureDiv.offsetHeight;
      document.body.removeChild(measureDiv);

      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const scrollVh = isDesktop ? vh : cssVh;

      // These must match intro.ts calculations
      const INTRO_SCROLL_DISTANCE = 2; // from config
      const introScrollDist = INTRO_SCROLL_DISTANCE * scrollVh;
      const pageScrollDist = pageCount > 1 ? (pageCount - 1) * (isDesktop ? vw : cssVh) : 0;
      const totalScrollDistCalc = introScrollDist + pageScrollDist;
      const introEnd = introScrollDist / totalScrollDistCalc;

      switch (targetId) {
        case 'home':
          // Scroll to top (progress 0)
          return triggerStart;

        case 'work-social-media':
          // First work page — right at intro end
          return triggerStart + totalDist * introEnd;

        case 'work-product-photography': {
          // Second work page
          const pageProgress = 1 / pageCount;
          return triggerStart + totalDist * (introEnd + (1 - introEnd) * pageProgress);
        }

        case 'work-key-visuals': {
          // Third work page
          const pageProgress = 2 / pageCount;
          return triggerStart + totalDist * (introEnd + (1 - introEnd) * pageProgress);
        }

        case 'contact':
          // Scroll past the hero entirely (to the bottom / outro)
          return triggerEnd + 1;

        default:
          return 0;
      }
    }

    // ---------- Item click ----------
    items.forEach((btn) => {
      btn.addEventListener('click', () => {
        const targetId = btn.dataset.menuTarget;
        if (!targetId) return;

        const scrollY = getScrollTarget(targetId);

        close(() => {
          gsap.to(window, {
            scrollTo: { y: scrollY, autoKill: false },
            duration: MENU_SCROLL_DURATION,
            ease: MENU_SCROLL_EASE,
          });
        });
      });
    });

    // ---------- Close button ----------
    closeBtn.addEventListener('click', () => close());

    // ---------- Overlay click closes menu ----------
    overlayBg.addEventListener('click', () => close());

    // ---------- Listen for open event from MenuCollapsed ----------
    window.addEventListener('menu:expand', ((e: CustomEvent<{ activeSection?: string }>) => {
      open(e.detail?.activeSection);
    }) as EventListener);
  }
</script>

<style>
  /* Nav container — covers viewport when open, hidden by default */
  .menu-expanded {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 200;
  }

  /* Full-screen dark overlay — NO blur, just semi-transparent black */
  .menu-expanded :global([data-menu-overlay]) {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.4);
  }

  /* Content container — positioned at bottom, aligned with collapsed menu via JS */
  .menu-content {
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
    width: 335px;
  }

  /* Items stack */
  .menu-items {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 2px;
    width: 100%;
  }

  /* Pill — common base (inactive state) */
  .menu-item {
    display: flex;
    align-items: center;
    padding: 32px 42px;
    border: none;
    border-radius: 100px;
    font-family: var(--font-body);
    font-size: 16px;
    font-weight: 500;
    line-height: 20px;
    color: #1A1A1A;
    cursor: pointer;
    white-space: nowrap;
    transition: background 0.2s ease;
    background: rgba(255, 255, 255, 0.70);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
  }

  /* Work items: match collapsed menu pill width, category left + subcategory right */
  .menu-item--work {
    width: 540px;
    justify-content: space-between;
  }

  /* Hover / focus — solid white */
  .menu-item:hover,
  .menu-item:focus-visible {
    background: var(--color-white);
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
  }

  /* Active item — solid white, no blur */
  .menu-item.active {
    background: var(--color-white);
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
  }

  .menu-item:focus-visible {
    outline: 2px solid var(--color-white);
    outline-offset: 2px;
  }

  /* Close button — pill shape, same frosted glass as inactive items */
  .close-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 108px;
    height: 88px;
    padding: 32px 42px;
    border: none;
    border-radius: 100px;
    background: rgba(255, 255, 255, 0.70);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    color: #1D1B20;
    cursor: pointer;
    transition: background 0.2s ease;
  }

  .close-btn:hover,
  .close-btn:focus-visible {
    background: var(--color-white);
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
  }

  .close-btn:focus-visible {
    outline: 2px solid var(--color-white);
    outline-offset: 2px;
  }

  /* Mobile: work items match collapsed menu width */
  @media (max-width: 768px) {
    .menu-content {
      width: calc(100vw - 56px);
    }

    .menu-item--work {
      width: calc(100vw - 56px);
    }
  }
</style>
